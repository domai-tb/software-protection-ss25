enc_bytecode = [
    0xed, 0xcf, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb,
    0xcb, 0x1e, 0xca, 0xcb, 0xcb, 0xfc, 0xd8, 0xcb,
    0xcb, 0x3d, 0xca, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb,
    0xbe, 0xdc, 0x3c, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb,
    0x1e, 0xca, 0xcb, 0xcb, 0x24, 0x75, 0xcb, 0xcb,
    0x3d, 0xca, 0xcb, 0xcb, 0xcb, 0xcb, 0xbe, 0xdc,
    0x7c, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0x1e, 0xca,
    0xcb, 0xcb, 0xcb, 0xcb, 0x3d, 0xca, 0xcb, 0xcb,
    0xcb, 0xcb, 0x9a, 0xcf, 0xcb, 0xcb, 0x1e, 0xc9,
    0xcb, 0xcb, 0xce, 0xcb, 0xcb, 0x4b, 0xcb, 0xcb,
    0xcb, 0xcb, 0xcb, 0xcb, 0xfb, 0xca, 0xcb, 0xcb,
    0xcb, 0xcb, 0xcb, 0xca, 0xcb, 0xcb, 0xc9, 0xcb,
    0xcb, 0xc8, 0xcb, 0xcb, 0xc5, 0xc6, 0xcb, 0xcb,
    0xc8, 0xcb, 0xcb, 0x9a, 0xe2, 0xcb, 0xcb, 0xed,
    0xdb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0x1e, 0xca,
    0xcb, 0xcb, 0xcb, 0xcb, 0x3d, 0xca, 0xcb, 0xcb,
    0xcb, 0xcb, 0x9a, 0xcf, 0xcb, 0xcb, 0x9a, 0x11,
    0xca, 0xcb, 0x1e, 0xc9, 0xcb, 0xcb, 0xc1, 0xcb,
    0xcb, 0x4b, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb,
    0xfb, 0xca, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xca,
    0xcb, 0xcb, 0xc9, 0xcb, 0xcb, 0xc8, 0xcb, 0xcb,
    0xc5, 0xc6, 0xcb, 0xcb, 0xc8, 0xcb, 0xcb, 0x9a,
    0xe2, 0xcb, 0xcb, 0xed, 0xdb, 0xcb, 0xcb, 0xcb,
    0xcb, 0xcb, 0x1e, 0xca, 0xcb, 0xcb, 0xca, 0xcb,
    0xcb, 0x3d, 0xca, 0xcb, 0xcb, 0xcb, 0xcb, 0x9a,
    0xcf, 0xcb, 0xcb, 0x9a, 0xb4, 0xca, 0xcb, 0xed,
    0xdf, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0x1e, 0xca,
    0xcb, 0xcb, 0xc1, 0xcb, 0xcb, 0x3d, 0xca, 0xcb,
    0xcb, 0xcb, 0xcb, 0x9a, 0xcf, 0xcb, 0xcb, 0x4b,
    0xc9, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xfb, 0xc8,
    0xcb, 0xcb, 0xc9, 0xcb, 0xcb, 0xed, 0xdf, 0xcb,
    0xcb, 0xcb, 0xcb, 0xcb, 0xfb, 0xca, 0xcb, 0xcb,
    0xcb, 0xcb, 0x09, 0xcf, 0xcb, 0xcb, 0xca, 0xcb,
    0xcb, 0xc8, 0xcb, 0xcb, 0xc5, 0xd9, 0xcb, 0xcb,
    0xcf, 0xcb, 0xcb, 0x9a, 0xcf, 0xcb, 0xcb, 0x9a,
    0x39, 0xcb, 0xcb, 0xed, 0xc7, 0xcb, 0xcb, 0xcb,
    0xcb, 0xbe, 0xdc, 0xfc, 0xcb, 0xcb, 0xca, 0xcb,
    0xcb, 0xfb, 0xc9, 0xcb, 0xcb, 0xca, 0xcb, 0xcb,
    0xed, 0xdf, 0xcb, 0xcb, 0xc8, 0xcb, 0xcb, 0xfb,
    0xcf, 0xcb, 0xcb, 0xc8, 0xcb, 0xcb, 0x3a, 0xcf,
    0xcb, 0xcb, 0xc9, 0xcb, 0xcb, 0xce, 0xcb, 0xcb,
    0x4b, 0xcd, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xfb,
    0xcc, 0xcb, 0xcb, 0xcd, 0xcb, 0xcb, 0xad, 0xcc,
    0xcb, 0xcb, 0xce, 0xcb, 0xcb, 0xc3, 0xcb, 0xcb,
    0x3d, 0xc3, 0xcb, 0xcb, 0xcb, 0xcb, 0xbe, 0xdc,
    0xfc, 0xcb, 0xcb, 0xcb, 0xcb, 0xbe, 0xdc, 0x3c,
    0xcb, 0xcb, 0xca, 0xcb, 0xcb, 0xfb, 0xc9, 0xcb,
    0xcb, 0xca, 0xcb, 0xcb, 0x3d, 0xc9, 0xcb, 0xcb,
    0xcb, 0xcb, 0xbe, 0xdc, 0x3c, 0xcb, 0xcb, 0xcb,
    0xcb, 0xbe, 0xdc, 0x7c, 0xcb, 0xcb, 0xca, 0xcb,
    0xcb, 0xfb, 0xc9, 0xcb, 0xcb, 0xca, 0xcb, 0xcb,
    0x3d, 0xc9, 0xcb, 0xcb, 0xcb, 0xcb, 0xed, 0xdf,
    0xcb, 0xcb, 0xcb, 0xcb, 0xbe, 0xdd, 0xfc, 0xcb,
    0xcb, 0xca, 0xcb, 0xcb, 0xfb, 0xc9, 0xcb, 0xcb,
    0xca, 0xcb, 0xcb, 0x1e, 0xc8, 0xcb, 0xcb, 0xca,
    0xcb, 0xcb, 0xad, 0xc8, 0xcb, 0xcb, 0xc9, 0xcb,
    0xcb, 0xcf, 0xcb, 0xcb, 0x3d, 0xcf, 0xcb, 0xcb,
    0xcb, 0xcb, 0xcb, 0x9a, 0x1c, 0x35, 0x34, 0x34,
    0x9a, 0x19, 0x35, 0x34, 0x34, 0xed, 0xdb, 0xcb,
    0xcb, 0xcb, 0xcb, 0xbe, 0xdc, 0x7c, 0xcb, 0xcb,
    0xca, 0xcb, 0xcb, 0xfb, 0xc9, 0xcb, 0xcb, 0xca,
    0xcb, 0xcb, 0x3d, 0xc9, 0xcb, 0xcb, 0xcb, 0xcb,
    0x9a, 0xcf, 0xcb, 0xcb, 0xed, 0xdb, 0xcb, 0xcb,
    0xcb, 0xcb, 0xcb, 0xfb, 0xca, 0xcb, 0xcb, 0xcb,
    0xcb
]

# Predefined magic numbers
magic_numer_1 = -0x35
magic_numer_2 = 0x16    
magic_numer_3 = -0x36   
magic_numer_4 = magic_numer_1  
magic_numer_5 = -0x3435

# Decrypt bytecode by applying "key"
dec_bytecode = [b ^ 0xCB for b in enc_bytecode]

# Define symbolic state
VIP = 0
REGISTERS = [0] * 256

def vm_execute(dec_bytecode, input_num):
    global REGISTERS
    global VIP
    
    def read_uint8(offset):
        return dec_bytecode[offset]
    
    def read_uint32(offset):
        # read 4 bytes little endian from list of ints
        b = dec_bytecode[offset:offset+4]
        return b[0] | (b[1] << 8) | (b[2] << 16) | (b[3] << 24)
    
    def read_int64(offset):
        # read 8 bytes little endian signed
        b = dec_bytecode[offset:offset+8]
        val = 0
        for i in range(8):
            val |= b[i] << (8 * i)
        # convert to signed 64-bit
        if val & (1 << 63):
            val -= 1 << 64
        return val
    
    while True:
        try:
            op = read_uint8(VIP)
        except IndexError:
            # bytecode is finished
            break

        op_gt_0x80 = op > 0x80
        
        if op == 0x80:
            # Halt
            print(f'{hex(VIP)}: HALT')
            break
        
        if op_gt_0x80:
            # High opcode range
            if op == 0xdd:
                reg_index = read_uint8(VIP + 1)
                print(f'{hex(VIP)}: RET r{reg_index}')
                return REGISTERS[reg_index]
            
            if op > 0xdd:
                if op == 0xf1:
                    # XOR: REGISTERS[dest] = REGISTERS[Y] ^ REGISTERS[Z]
                    reg_z = read_uint8(VIP + 1)
                    reg_y = read_uint8(VIP + 5)
                    dest = read_uint8(VIP + 9)
                    REGISTERS[dest] = REGISTERS[reg_y] ^ REGISTERS[reg_z]
                    print(f'{hex(VIP)}: XOR r{dest} r{reg_y} r{reg_z}')
                    VIP += 13
                    continue
                
                if op == 0xf6:
                    # Load pointer from src into dest register (simulate by value copy)
                    src_reg = read_uint8(VIP + 1)
                    dest_reg = read_uint8(VIP + 5)
                    REGISTERS[dest_reg] = REGISTERS[src_reg]
                    print(f'{hex(VIP)}: LOAD [r{dest_reg}] [r{src_reg}]')
                    VIP += 9
                    continue
                
                # Unknown opcode in this range - redispatch
                print(f'{hex(VIP)}: UNKNOWN OPERATION')
                VIP += 1
                continue
            
            if op == 0xc2:
                # CMPLE: reg[X] = reg[Y] <= reg[Z]
                reg_x = read_uint8(VIP + 1)
                reg_y = read_uint8(VIP + 5)
                reg_z = read_uint8(VIP + 9)
                REGISTERS[reg_x] = 1 if REGISTERS[reg_y] <= REGISTERS[reg_z] else 0
                print(f'{hex(VIP)}: CMPLE r{reg_x} r{reg_y} r{reg_z} // r{reg_x} = {REGISTERS[reg_x]}')
                VIP += 13
                continue
            
            if op == 0xd5:
                # Load immediate into dest register
                dest_reg = read_uint8(VIP + 1)
                immediate = read_uint32(VIP + 5)
                REGISTERS[dest_reg] = immediate
                print(f'{hex(VIP)}: MOV r{dest_reg} {immediate}')
                VIP += 9
                continue
            
            # Redispatch (unknown opcode)
            print(f'{hex(VIP)}: UNKNOWN OPERATION')
            VIP += 1
            continue
        
        else:
            # Low opcode range
            if op == 0x30:
                # mov dest_idx src_idx
                dest_idx = read_uint8(VIP + 1)
                src_idx = read_uint8(VIP + 5)
                REGISTERS[dest_idx] = REGISTERS[src_idx]
                print(f'{hex(VIP)}: MOV r{dest_idx} r{src_idx}')
                VIP += 9
                continue
            
            if op <= 0x30:
                if op == 0x26:
                    # Compute memory address with local stack (simulate by adding offset)
                    local_stack_addr = 0x100000  # Just an arbitrary address base
                    dest_reg = read_uint8(VIP + 5)
                    offset = read_uint32(VIP + 1)
                    REGISTERS[dest_reg] = local_stack_addr + offset
                    print(f'{hex(VIP)}: CADDR r{dest_reg} // r{dest_reg} = {REGISTERS[dest_reg]}')
                    VIP += 9
                    continue
                
                if op == 0x0e:
                    # If register at source is zero, branch
                    src_reg = read_uint8(VIP + 5)
                    if REGISTERS[src_reg] == 0:
                        VIP += 9
                        op = read_uint8(VIP)
                        if op == 0x80:
                            break
                        continue
                    else:
                        VIP += 1
                        continue
                
                if op == 0x00:
                    # less-than comparison flag
                    reg_x = read_uint8(VIP + 1)
                    reg_y = read_uint8(VIP + 5)
                    reg_z = read_uint8(VIP + 9)
                    REGISTERS[reg_z] = 1 if REGISTERS[reg_x] < REGISTERS[reg_y] else 0
                    print(f'{hex(VIP)}: CMPLE r{reg_z} r{reg_x} r{reg_z} // r{reg_z} = {REGISTERS[reg_z]}')
                    VIP += 13
                    continue
                
                # Redispatch unknown opcode <= 0x30
                VIP += 1
                continue
            
            if op == 0x66:
                # ADD: reg[dest] = reg[X] + reg[Y]
                reg_y = read_uint32(VIP + 1)
                reg_x = read_uint32(VIP + 5)
                dest = read_uint32(VIP + 9)
                REGISTERS[dest] = REGISTERS[reg_y] + REGISTERS[reg_x]
                print(f'{hex(VIP)}: ADD r{dest} r{reg_y} r{reg_x}')
                VIP += 13
                continue
            
            # JMP: unconditional jump
            jump_offset = read_uint32(VIP + 1)
            print(f'{hex(VIP)}: JMP {hex(jump_offset)}')
            VIP = VIP + jump_offset + 1
            continue
    
    # End of VM execution
    return None

# Run the VM with example bytecode and input number
result = vm_execute(dec_bytecode, input_num=6)
print("VM returned:", result)
