from argparse import ArgumentParser
from z3 import Solver, unsat
from miasm.analysis.binary import Container
from miasm.analysis.machine import Machine
from miasm.core.locationdb import LocationDB
from miasm.ir.symbexec import SymbolicExecutionEngine
from miasm.ir.translators.z3_ir import TranslatorZ3

# ---- Argument Parser ----
parser = ArgumentParser("MBA Removal with Symbolic Execution")
parser.add_argument("target_binary", help="Target binary path")
parser.add_argument("--address", help="Starting address for emulation. If not set, use the entrypoint")
options = parser.parse_args()

# ---- Setup Miasm ----
loc_db = LocationDB()
container = Container.from_stream(open(options.target_binary, 'rb'), loc_db)
machine = Machine(container.arch)
mdis = machine.dis_engine(container.bin_stream, loc_db=loc_db)

# Determine starting address
if options.address is None:
    start_addr = container.entry_point
else:
    try:
        start_addr = int(options.address, 0)
    except ValueError:
        start_addr = loc_db.get_name_offset(options.address)

asm_cfg = mdis.dis_multiblock(start_addr)
lifter = machine.lifter_model_call(mdis.loc_db)
ira_cfg = lifter.new_ircfg_from_asmcfg(asm_cfg)

# ---- Utility Functions ----
def branch_cannot_be_taken(expression, jump_target):
    solver = Solver()
    translator = TranslatorZ3()
    solver.add(translator.from_expr(expression) == translator.from_expr(jump_target))
    return solver.check() == unsat

# ---- Symbolic Execution and MBA Detection ----
for basic_block in asm_cfg.blocks:
    address = basic_block.lines[0].offset
    sb = SymbolicExecutionEngine(lifter)
    expr = sb.run_block_at(ira_cfg, address)
    jump_instruction = basic_block.lines[-1]

    # Skip non-conditional expressions
    if not expr.is_cond():
        if jump_instruction.name in ["JZ", "JNZ", "JLE"]:
            target = int(expr)
            real_target = loc_db.get_location_offset(jump_instruction.args[0].loc_key)
            if target == real_target or target == jump_instruction.offset + len(jump_instruction.b):
                print(f"Edge at {hex(jump_instruction.offset)} to {hex(target)} is never taken")
        continue

    src1 = expr.src1
    src2 = expr.src2

    # Fix operand order if needed
    if int(src2) - int(jump_instruction.offset) != len(jump_instruction.b):
        if int(src1) - int(jump_instruction.offset) == len(jump_instruction.b):
            src1, src2 = src2, src1
        else:
            print("Error with instruction calculation!")
            continue

    if branch_cannot_be_taken(expr, src1):
        print(f"Edge at {hex(jump_instruction.offset)} (in basic block {hex(address)}) to {src1} is never taken")
    elif branch_cannot_be_taken(expr, src2):
        print(f"Edge at {hex(jump_instruction.offset)} (in basic block {hex(address)}) to {src2} is never taken")
